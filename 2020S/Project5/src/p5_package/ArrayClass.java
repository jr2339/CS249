package p5_package;

public class ArrayClass
{
    /**
     * array capacity member
     */
    private int arrayCapacity;

    /**
     * array size member
     */
    private int arraySize;

    /**
     * constant for default capacity
     */
    private static final int DEFAULT_CAPACITY = 10;

    /**
     * constant for failed access
     */
    public static final int FAILED_ACCESS = -999999;

    /**
     * local array member
     */
    private int[] localArray;

    /**
     * default constructor, initializes array to default capacity
     */
    public ArrayClass()
    {
        arrayCapacity = DEFAULT_CAPACITY;
        localArray = new int[DEFAULT_CAPACITY];
        arraySize = 0;
    }

    /**
     * Initializing constructor, initializes array to specified capacity
     * Note: Must not be initialized to a capacity less than the default capacity
     * @param capacity - maximum capacity specification for the array
     */
    public ArrayClass(int capacity)
    {
        arrayCapacity = capacity;
        localArray = new int [capacity];
        arraySize = 0;
    }

    /**
     * Initializing constructor, initializes array to specified capacity,
     * size to specified value, then fills all elements with specified size value
     * Note: If given capacity less than default capacity, capacity must be set to default capacity
     * Note: If given size is greater than given capacity, capacity must be set to given size
     * @param capacity - maximum capacity specification for the array
     * @param size - sets the number of items to be filled in array, and sets the size of the ArrayClass object
     * @param fillValue - value to be placed in all elements of initialized array up to the size
     */
    public ArrayClass(int capacity, int size, int fillValue)
    {
        int index;

        localArray = new int[capacity];
        arrayCapacity = capacity;
        arraySize = size;

        for(index = 0; index < arraySize; index++)
        {
            localArray[index] = fillValue;
        }
    }

    /**
     * Copy constructor, initializes array to size and capacity of copied array,
     * then copies only the elements up to the given size
     * @param copied - ArrayClass object to be copied
     */
    public ArrayClass(ArrayClass copied)
    {
        int index;

        arrayCapacity = copied.arrayCapacity;
        arraySize = copied.arraySize;
        localArray = new int[this.arrayCapacity];

        for(index = 0; index < arraySize; index++)
        {
            localArray[index] = copied.localArray[index];
        }
    }

    /**
     * Accesses item in array at specified index if index within array size bounds
     * @param accessIndex - index of requested element value
     * @return - boolean success if appended, or failure if array was full
     */
    public int accessItemAt(int accessIndex)
    {
        if(accessIndex <= arraySize)
        {
            return localArray[accessIndex];
        }
        return FAILED_ACCESS;
    }

    /**
     * Appends item to end of array, if array is not full, e.g., no more values can be added
     * @param newValue- value to be appended to array
     * @return boolean success if appended, or failure if array was full
     */
    boolean appendItem(int newValue)
    {
        if(!isFull())
        {
            localArray[arraySize] = newValue;
            arraySize++;
            return true;
        }
        return false;
    }

    /**
     * Clears array of all valid values by setting array size to zero, values remain in array but are not accessible
     */
    public void clear()
    {
        arraySize = 0;
    }

    /**
     * Simple array dump for testing purposes
     */
    @SuppressWarnings("unused")
    private void dump()
    {
        int index;
        String stringDump = "";

        for ( index = 0; index < arraySize; index++ )
        {
            if ( index > 0 )
            {
                stringDump += ", ";
            }
            stringDump = stringDump + localArray[index];
        }
        System.out.print (stringDump);
    }

    /**
     * Description: Gets current capacity of array
     * Note: capacity of array indicates number of values the array can hold
     * @return - capacity of array
     */
    public int getCurrentCapacity()
    {
        return arrayCapacity;
    }

    /**
     * Description: Gets current size of array
     * Note: size of array indicates number of valid or viable values in the array
     * @return - size of array
     */
    public int getCurrentSize()
    {
        return arraySize;
    }

    /**
     * Generates random number between given low and high values
     * @param low - lowest value that will be generated by method
     * @param high - highest value that will be generated by method
     * @return - the generated random value
     */
    private int getRandBetween(int low, int high)
    {
        int value, range = high - low + 1;

        value = (int)( Math.random() * range );

        return value;
    }

    /**
     * Description: Inserts item to array at specified index if array is not full, e.g., no more values can be added
     * Note: Value is inserted at given index, all data from that index to the end of the array is shifted up by one
     * Note: Value can be inserted after the last valid element but not at any index past that point
     * @param insertIndex - index of element into which value is to be inserted
     * @param newValue - value to be inserted into array
     * @return - boolean success if inserted, or failure if array was full
     */
    public boolean insertItemAt(int insertIndex, int newValue)
    {
        int index;

        if(!isFull() && insertIndex >= 0 && insertIndex <= arraySize)
        {
            index = arraySize;
            while(index > insertIndex)
            {
                localArray[index] = localArray[index++];
                index--;
            }
            localArray[insertIndex] = newValue;
            arraySize++;
            return true;
        }
        return false;
    }

    /**
     * Tests for size of array equal to zero, no valid values stored in array
     * @return - boolean result of test for empty
     */
    public boolean isEmpty()
    {
        return arraySize == 0;
    }

    /**
     * Tests for size of array equal to capacity, no more values can be added
     * @return - boolean result of test for full
     */
    public boolean isFull()
    {
        return arraySize == arrayCapacity;
    }

    /**
     * Tests for value found in object array; returns true if value within array, false otherwise
     * @param testVal - value to be tested
     * @return - boolean true if value is found in array, false otherwise
     */
    public boolean isInArray(int testVal)
    {
        int index;

        for(index = 0; index < arraySize; index++)
        {
            if(localArray[ index ] == testVal)
            {
                return true;
            }
        }
        return false;
    }

    /**
     * Loads a specified number of unique random numbers in object
     * Note: This method overwrites all data in the array up to the number of randoms requested
     * Note: If requested number of randoms is greater than the array capacity, the array is resized
     * Note: Size is set to number of random numbers requested
     * Exceptional Condition: If more values are requested than are possible given the range of numbers,
     * method returns false, otherwise, it returns true
     * @param numRands - number of random values requested
     * @param lowLimit - lowest value to be generated
     * @param highLimit - highest value to be generated
     * @return - boolean true if method successful; false otherwise
     */
    public boolean loadUniqueRandoms(int numRands, int lowLimit, int highLimit)
    {
        {
            int index;
            int randomNumber;

            if( (numRands < highLimit - lowLimit) && (highLimit > lowLimit))
            {
                if(numRands > arraySize)
                {
                    resize(numRands);
                }
                clear();
                for(index = 0; index < numRands; index++)
                {
                    randomNumber = getRandBetween(lowLimit, highLimit);
                    if(!isInArray(randomNumber))
                    {
                        appendItem(randomNumber);
                    }
                    else
                    {
                        index--;
                    }
                }
                arraySize = numRands;
                return true;
            }
            return false;
        }
    }

    /**
     * Description: Removes item from array at specified index if index within array size bounds
     * Note: Each data item from the element immediately above the remove index to the end of the array is moved
     * down by one element
     * @param removeIndex - index of element value to be removed
     * @return - removed value if successful, FAILED_ACCESS (-999999) if not
     */
    public int removeItemAt(int removeIndex)
    {
        int index, removedItem;

        if(removeIndex >= 0 && removeIndex < arraySize)
        {
            removedItem = localArray[removeIndex];
            index = removeIndex;
            arraySize--;

            while(index < arraySize)
            {
                localArray[index] = localArray[index++];
                index++;
            }
            return removedItem;
        }
        return FAILED_ACCESS;
    }

    /**
     * Description: Resets array capacity, copies current size and current size number of elements
     * Exception: Method will not resize capacity below current array size, returns false if this is attempted,
     * true otherwise
     * @param newCapacity - new capacity to be set; must be larger than current capacity
     * @return - boolean condition of resize success or failure
     */
    public boolean resize(int newCapacity)
    {
        int index;
        int[] newArr = new int[newCapacity];

        if(newCapacity > arrayCapacity)
        {
            for(index = 0; index < arraySize; index++)
            {
                newArr[index] = localArray[index];
            }
            arrayCapacity = newCapacity;
            localArray = newArr;
            return true;
        }
        return false;
    }

    /**
     * Merges values brought in between a low and high index segment of an array
     * Note: uses locally sized single array for temporary storage
     * @param lowIndex - lowest index of array segment to be managed
     * @param middleIndex - middle index of array segment to be managed
     * @param highIndex - high index of array segment to be managed
     */
    private void runMerge(int lowIndex, int middleIndex, int highIndex)
    {
        int leftIndex = lowIndex;
        int rightIndex = middleIndex + 1;
        int position = leftIndex;
        int startIndex;
        int[] sortedArr = new int[highIndex - lowIndex + 1];

        for(startIndex = lowIndex; startIndex <= highIndex; startIndex++)
        {
            sortedArr[startIndex] = localArray[startIndex];
        }
        while(leftIndex <= middleIndex || rightIndex <= highIndex)
        {
            if(leftIndex <= middleIndex && rightIndex <= highIndex)
            {
                if(sortedArr[leftIndex] <= sortedArr[rightIndex])
                {
                    localArray[position] = sortedArr[leftIndex];
                    leftIndex += 1;
                }
                else
                {
                    localArray[position] = sortedArr[rightIndex];
                    rightIndex += 1;
                }
            }
            else if(leftIndex <= middleIndex)
            {
                localArray[position] = sortedArr[leftIndex];
                leftIndex += 1;
            }
            else if(rightIndex <= highIndex)
            {
                localArray[position] = sortedArr[rightIndex];
                rightIndex = rightIndex + 1;
            }
            position = position + 1;
        }
    }

    /**
     * Data sorted using merge sort algorithm
     * Note: Call runMergeSortHelper with lower and upper indices of array to be sorted
     */
    public void runMergeSort()
    {
        runMergeSortHelper( 0, arraySize - 1 );
    }

    /**
     * Merge sort helper, places low and high indices of array segment to be processed into recursive method,
     * then sorts data using merge sort algorithm
     * @param lowIndex - lowest index of array segment to be managed; this varies as the segments are broken down recursively
     * @param highIndex - highest index of array segment to be managed; this varies as the segments are broken down recursively
     */
    private void runMergeSortHelper(int lowIndex, int highIndex)
    {
        int middleIndex;

        if(lowIndex < highIndex)
        {
            middleIndex = (lowIndex + highIndex)/2;
            runMergeSortHelper(lowIndex, middleIndex);
            runMergeSortHelper(middleIndex + 1, highIndex);
            runMerge(lowIndex, middleIndex, highIndex);
        }
    }

    /**
     * partitions array using the first value as the partition;
     * when this method is complete the partition value is in the correct location in the array
     * @param lowIndex - low index of array segment to be partitioned
     * @param highIndex - high index of array segment to be partitioned
     * @return integer index of partition pivot
     */
    private int runPartition(int lowIndex, int highIndex)
    {
        int pivotValue = localArray[lowIndex];
        int bottomCursor = lowIndex + 1;
        int topCursor = highIndex;

        boolean complete = false;

        while (!complete)
        {
            while (bottomCursor <= topCursor && localArray[bottomCursor] <=
                    pivotValue)
            {
                bottomCursor += 1;
            }
            while (localArray[topCursor] >= pivotValue && topCursor >=
                    bottomCursor)
            {
                topCursor -= 1;
            }
            if (topCursor < bottomCursor)
            {
                complete = true;
                swapValuesAtIndex(lowIndex, topCursor);
            }
            else
            {
                swapValuesAtIndex(bottomCursor, topCursor);
            }
        }
        return topCursor;
    }

    /**
     * Data sorted using quick sort algorithm
     * Note: Call runQuickSortHelper with lower and upper indices of array to be sorted
     */
    public void runQuickSort()
    {
        runQuickSortHelper(0, arraySize - 1);
    }

    /**
     * helper method run with parameters that support recursive access
     * @param lowIndex - low index of the segment of the array to be processed
     * @param highIndex - high index of the segment of the array to be processed
     */
    private void runQuickSortHelper(int lowIndex, int highIndex)
    {
        int index = runPartition(lowIndex, highIndex);

        if(lowIndex < index - 1)
        {
            runQuickSortHelper(lowIndex, index - 1);
        }
        if(index < highIndex)
        {
            runQuickSortHelper(index, highIndex);
        }
    }

    /**
     * Sorts data using the Shell's sort algorithm
     */
    public void runShellSort()
    {
        int gap, index, secondIndex;
        int arrSize = arraySize;

        for(gap = arrSize/2; gap > 0; gap /= 2)
        {
            for(index = gap; index < arrSize; index++)
            {
                for(secondIndex = index; secondIndex >= gap; secondIndex -= gap)
                {
                    if(localArray[index - gap] > localArray[index])
                    {
                        swapValuesAtIndex(secondIndex, secondIndex - gap);
                    }
                }

            }
        }
    }

    /**
     * swaps values in the object array by taking in the indices of the array locations
     * Note: for a small level of optimization, this method does not swap values if the indices are the same
     * @param oneIndex - index of the of the values to be swapped
     * @param otherIndex - index of the other value to be swapped
     */
    private void swapValuesAtIndex(int oneIndex, int otherIndex)
    {
        int temp = localArray[ oneIndex ];

        if( oneIndex != otherIndex )
        {
            localArray[ oneIndex ] = localArray[ otherIndex ];

            localArray[ otherIndex ] = temp;
        }
    }
}